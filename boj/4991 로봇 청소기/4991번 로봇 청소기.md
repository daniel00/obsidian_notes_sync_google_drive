---
title: "4991번: 로봇 청소기"
source: "https://www.acmicpc.net/problem/4991"
author:
  - "[[스타트링크 (Startlink)]]"
published:
created: 2025-05-02
description:
tags:
  - "clippings"
---
| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 12868 | 4512 | 2989 | 32.419% |

오늘은 직사각형 모양의 방을 로봇 청소기를 이용해 청소하려고 한다. 이 로봇 청소기는 유저가 직접 경로를 설정할 수 있다.

방은 크기가 1×1인 정사각형 칸으로 나누어져 있으며, 로봇 청소기의 크기도 1×1이다. 칸은 깨끗한 칸과 더러운 칸으로 나누어져 있으며, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿀 수 있다.

일부 칸에는 가구가 놓여져 있고, 가구의 크기도 1×1이다. 로봇 청소기는 가구가 놓여진 칸으로 이동할 수 없다.

로봇은 한 번 움직일 때, 인접한 칸으로 이동할 수 있다. 또, 로봇은 같은 칸을 여러 번 방문할 수 있다.

방의 정보가 주어졌을 때, 더러운 칸을 모두 깨끗한 칸으로 만드는데 필요한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

입력은 여러 개의 테스트케이스로 이루어져 있다.

각 테스트 케이스의 첫째 줄에는 방의 가로 크기 w와 세로 크기 h가 주어진다. (1 ≤ w, h ≤ 20) 둘째 줄부터 h개의 줄에는 방의 정보가 주어진다. 방의 정보는 4가지 문자로만 이루어져 있으며, 각 문자의 의미는 다음과 같다.

- `.`: 깨끗한 칸
- `*`: 더러운 칸
- `x`: 가구
- `o`: 로봇 청소기의 시작 위치

더러운 칸의 개수는 10개를 넘지 않으며, 로봇 청소기의 개수는 항상 하나이다.

입력의 마지막 줄에는 0이 두 개 주어진다.

각각의 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 이동 횟수의 최솟값을 한 줄에 하나씩 출력한다. 만약, 방문할 수 없는 더러운 칸이 존재하는 경우에는 -1을 출력한다.

```
7 5
.......
.o...*.
.......
.*...*.
.......
15 13
.......x.......
...o...x....*..
.......x.......
.......x.......
.......x.......
...............
xxxxx.....xxxxx
...............
.......x.......
.......x.......
.......x.......
..*....x....*..
.......x.......
10 10
..........
..o.......
..........
..........
..........
.....xxxxx
.....x....
.....x.*..
.....x....
.....x....
0 0
```

```
8
49
-1
```

\> > > > > F번




#### 왜 비트마스크 등을 사용해서 "청소상태"를 점검하면서 경로를 찾아야 하는지 이해가 되지 않았는데, Cursor AI가 좋은 예를 들어 주었다.
#### 결론은, "꼭 청소 상태를 점검" 하면서 최단 경로를 찾아야 한다!!!!!!



```txt
/*
일반 BFS와 비트마스크 BFS의 차이점을 설명하는 예시입니다.

더 복잡한 맵 예시:
. . * . .
. o . o .
. . @ . .
. o . * .
. . . . .

@: 로봇의 시작 위치 (2,2)
o: 더러운 칸 (3개) - (1,1), (1,3), (3,1)
*: 벽
.: 빈 칸

일반 BFS의 경우:
1. (2,2)에서 시작해서 가장 가까운 더러운 칸 (1,1)로 이동: 2칸
2. (1,1)에서 다음으로 가까운 (1,3)으로 이동: 2칸
3. (1,3)에서 마지막 (3,1)로 이동: 4칸
총 이동 거리: 8칸

이동 경로:
(2,2) -> (1,2) -> (1,1) [첫 번째 더러운 칸]
(1,1) -> (1,2) -> (1,3) [두 번째 더러운 칸]
(1,3) -> (2,3) -> (2,2) -> (2,1) -> (3,1) [세 번째 더러운 칸]

비트마스크 BFS의 경우:
상태 = (현재위치, 청소상태)
더러운 칸의 상태: (1,1)=001, (1,3)=010, (3,1)=100

최적 경로:
(2,2) -> (2,1) -> (3,1) [상태: 100] : 2칸
(3,1) -> (2,1) -> (1,1) [상태: 101] : 2칸
(1,1) -> (1,2) -> (1,3) [상태: 111] : 2칸
총 이동 거리: 6칸

이 예시에서 일반 BFS는 단순히 현재 위치에서 
가장 가까운 더러운 칸을 선택하는 그리디 방식을 사용하여
전체 이동 거리가 8칸이 됩니다.

반면 비트마스크 BFS는 모든 가능한 방문 순서를 고려하여
전체적으로 가장 최적인 경로(6칸)를 찾아냅니다.

이처럼 단순 BFS로는 전체적인 최적해를 찾기 어렵고,
비트마스크를 이용한 상태 관리가 필요한 이유입니다.
*/
```