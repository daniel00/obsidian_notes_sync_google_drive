---
created: 2025-01-29 23:51
updated: 2025-01-29 23:51
tags: [boj, 1726, robot, bfs, cost, 로봇]
alias: []
---

created: 2025-01-29 23:51
updated: 2025-01-29 23:51

#### 1726 로봇 문제를 정리합니다.

bfs로 푸는 최단 경로 문제.
### 회전과, 이동에 대한 *모든 상태(경우)* 를 큐에 집어넣고 하나씩 빼면서 타겟을 찾는다.

같은 최단 경로라도, 직진을 우선한 경우가 최소 비용이기 때문에
	-직진을 우선한 경로를 먼저 점검하여 큐에 넣는다.  
	-그다음 회전을 고려한 경로를 점검하여 큐에 넣는다.
이 순서가 바뀌면 최소비용이 바뀔 수 있다.

이렇게 하면, 큐에서 꺼낼때 직진 우선 경로가 먼저 꺼내질거고, 
최초 도착점에 도착했을때의 비용이 바로 최소비용임을 보장 할 수 있다.

### visited 배열은 y,x,dir의 현재 좌표와, 방향까지 고려하여 3차원으로 구현해야 한다.


고전 포인트.
[github copilot ](http://github.com/copilot)에 질문하면서 문제를 풀어 봤는데,
많은 도움이 되기도 했고, 근데 자꾸 틀린 답을 내 놓아서 고생도 했다.
다음이 코파일럿이 나를 힘들게 했던 부분이다.

- dx,dy 초기화 잘못. x,y방향에 따른 값을 잘못 넣었었다.
동서남북으로 아래와 같이 표현해야 한다.
dx[] = {0,1,-1,0,0};
dy[] = {0,0,0,1,-1};

- y,x를 x,y로 표시 해서 혼선유발
row ===== y
col ===== x
로 정리 하였다.
아래처럼 y,x순서

![[Pasted image 20250130042019.png]]


아래는 boj제출하여 합격한 코드이다.

```cpp
#include <stdio.h>

#define MAX_SIZE (100+1)

// 방향 배열: 0(더미), 동(1), 서(2), 남(3), 북(4)
const int dx[] = {0, 1, -1, 0, 0}; // 동(1), 서(2)
const int dy[] = {0, 0, 0, 1, -1}; // 남(3), 북(4)

// 상태를 나타내는 구조체 정의
typedef struct {
    int y, x, dir, cost; // y는 row, x는 col
} State;

// 큐 구현을 위한 배열과 인덱스
State queue[MAX_SIZE * MAX_SIZE * 5];
int front = 0, rear = 0;

// 큐에 상태를 추가하는 함수
void enqueue(State s) {
    queue[rear++] = s;
}

// 큐에서 상태를 꺼내는 함수
State dequeue() {
    return queue[front++];
}

int main() {
    #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    #endif
    
    int m, n;
    int map[MAX_SIZE][MAX_SIZE];
    int visited[MAX_SIZE][MAX_SIZE][5] = {0}; // 방문 여부 체크 배열

    // 격자 맵 크기 입력
    scanf("%d %d", &m, &n);
    
    // 격자 맵 상태 입력
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            scanf("%d", &map[i][j]);
        }
    }

    // 시작점과 목표 지점 입력
    int sy, sx, sdir, ey, ex, edir; // y는 row, x는 col
    scanf("%d %d %d", &sy, &sx, &sdir);
    scanf("%d %d %d", &ey, &ex, &edir);

    // 큐에 시작 상태 추가
    enqueue((State){sy - 1, sx - 1, sdir, 0});
    visited[sy - 1][sx - 1][sdir] = 1;

    // BFS 탐색 시작
    while (front < rear) {
        State cur = dequeue();

        // 목표 지점에 도달한 경우
        if (cur.y == ey - 1 && cur.x == ex - 1 && cur.dir == edir) {
            printf("%d\n", cur.cost);
            return 0;
        }

        // 이동 명령 처리 (현재 방향을 유지하면서 이동)
        for (int k = 1; k <= 3; ++k) { // 한 번의 명령으로 최대 3칸까지 이동 가능
            int ny = cur.y + dy[cur.dir] * k;
            int nx = cur.x + dx[cur.dir] * k;

            if (ny < 0 || ny >= m || nx < 0 || nx >= n || map[ny][nx] == 1) break; // 격자를 벗어나거나 장애물이 있는 경우 멈춤

            if (!visited[ny][nx][cur.dir]) {
                visited[ny][nx][cur.dir] = 1;
                enqueue((State){ny, nx, cur.dir, cur.cost + 1});
            }
        }

        // 회전 명령 처리 (현재 위치에서 회전)
        for (int i = 1; i <= 4; ++i) {
            if (i != cur.dir && !visited[cur.y][cur.x][i]) {
                // 180도 회전인 경우 2번 명령 필요, 그 외에는 1번 명령 필요
                int turnCost = (cur.dir == 1 && i == 2) || (cur.dir == 2 && i == 1) || (cur.dir == 3 && i == 4) || (cur.dir == 4 && i == 3) ? 2 : 1;
                visited[cur.y][cur.x][i] = 1;
                enqueue((State){cur.y, cur.x, i, cur.cost + turnCost});
            }
        }
    }

    // 목표 지점에 도달하지 못한 경우
    printf("-1\n");
    return 0;
}
```