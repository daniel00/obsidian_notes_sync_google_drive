---
created: 2023-02-24 09:28.27
updated: 2024-05-17 00:06.48
---
### 바이너리 인덱스 트리에 대해서 정리해본다. 2023 03 04 토요일

바이너리 인덱스 트리(이하  bit)는
어떤 데이터의 부분합을 구하는데 logN, 데이터를 업데이트 하는데에  logN 시간에 가능하도록 하는 자료구조이다.   
실제로 노드가 있는 트리 형태의 자료구조는 아니고, 배열에 구현되는 자료구조이나 그 모양이 트리와 유사하여 바이너리 인덱스 트리라고 불린다.
그럼 지금부터 bit를 활용하면 어떻게  logN시간에 부분합과 업데이트가 가능한지, 그리고 bit를 응용한 알고리즘 문제풀이에 대해 알아보자.

\*문제 상황 요약

* 정수를 저장하는 크기 n인 배열이 주어진다.
* 인덱스 배열의 처음부터 i 까지의 합을 부분합이라고 정의한다.
* 이 부분합을 구하라면 질의(쿼리, query)가 m개 주어진다고 가정한다.

\*문제 풀이 요약

* 일반적인 부분합을 구하려면 O(n) 시간이 걸린다.
* 부분합을 미리 구해놓으면 O(1) 시간이 걸린다.
* 근데 원래의 데이터가 변경되면  부분합을 다시 구하는데 O(n)시간이 걸린다.
* bit를 활용하면  O(logn)시간에 가능하다.

\*부분합
어떤 배열 A가 주어지고, A\[0\] ~ A\[i\] 까지의 합을 부분합이라고 정의한다. 이를 prefix\_sum이라고 하겠다.
prefix\_sum은 워스케이스로 O(logN) 만에 구할 수 있다.
근데 모든 i에 대한 prefix\_sum을 한번만 구해놓으면, 이후  prefix\_sum은  O(1)인 상수시간에 구할수 있다.

예)
A\[5\] = {4,2,3,1,5}
P\[5\] = {4,6,12,13,18}

prefix\_sum\[3\] == P\[3\] == 13          O(1)
prefix\_sum\[4\] == P\[4\] == 18          O(1)

근데  배열 A의 값이 변경된다고 하면,  prefix\_sum 도 다시 구하여야 하므로,
A의 데이터가 한개 변경 될 때마다 P를 다시 구하는데 워스트케이스로 O(n)시간만큼이 필요하다.
bit를 활용해서 P를 구하는데 O(logN), 업데이트 하는데에 O(logN) 시간이 되도록 해보자.

지금부터 bit에 대해 설명한다.
bit배열의 이름은 T로 정한다.
다음의 이진수 덧셈 관계를 생각해보자.
십진수 13는 이진수로 1101 이다.
다시쓰면, 1101(b) = 1000(b) + 0100(b) + 0001(b) 이다.
즉, 13 = 8 + 4 + 1 이다
부분합을 구하는데 이러한 이준수의 계산법을 이용하는 것이다.
13 데이터를 다 더할 필요 없이 3번만 더하면 되도록 하자는 것이다. 이게 가능하도록 하는 배열의 형태가 bit 인 것이다.

지금부터 bit를 구현해 보겠다.
먼저 이진수의 규칙을 이해할 수 있도록 아래의 테이블을 채워보자

![[./_resources/바이너리_인덱스_트리,_bit_binary_index_tree.resources/image.png]]

위 테이블을 이해하는게 중요하다.
위의 예에서 각 십진수는 이진수로 표현되고,
이진수의 오른쪽 끝 '1' 이 가리키는 십진수 값이 중요하다.
그 값이 바로 자기자신부터 몇개의 부분합을 가지고 있는지를 나타낸다.
즉
16은 16개
15는  1개
14는    2
13은  1
........

각 수(결국 부분합을 저장하는 배열의 인덱스가 될 것이다) 가 책임지고 있는 부분합의 개수를 위 테이블 형태로 저장하는것 그게 바로 "바이너리 인덱스 트리" 이다!

\*부분합을 구할때 (sum)
예를 들어,
prefix\_sum(16) 은 T\[16\]이 될 것이고,
prefix\_sum(15) 는 T\[15\] + T\[14\] + T\[12\] + T\[8\] == T\[1111\]+T\[1110\]+T\[1100\]
prefix\_sum(14) 는 T\[14\] + T\[12\] + T\[8\] == T\[1110\]+T\[1100\]+T\[1000\]
prefix\_sum(12) 는 T\[13\] - T\[12\] - T\[8\] == T\[1101\]+T\[1100\]+T\[1000\]
...
...
이렇게 logn개만 더하면 된다.
위의 이진수 덧셈을 유심히  살펴보면,
LSB를 빼면서 더하고 있다. 1111 -> 1110 -> 1100
즉 , 부분합을 구하고자 하는 배열의 인덱스 idx부터 계속해서 LSB를 빼가며 logn 개만 더하면 된다!
다음이 수도 코드이다.

```
int sum(int idx)
{
    int sum = 0;

    while(idx<=1)
    {
sum = T[idx];
idx -= (idx & -idx);    //LSB를 구해서 빼준다
    }
}
```

\*업데이트 할 때(update)
업데이트 하고자 하는 수가 걸쳐있는 수에 대해서만 수행하면 된다.
따라서 업데이트도 logn만에 가능하다.

예를 들어,
A\[1\]의 값을 바꾸려고 한다면,
위 테이블에서 1이 걸쳐있는 수들인, 1,2,4,8,16 의 값만 업데이트 하면 된다.
업데이트 할때 유의할게 있는데, 원래 배열을 업데이트 한다는건,
기존값 대신 다른 값으로 바꾼다는 얘기이므로,
기존값을 먼저 빼주고 새로운 값을 넣어야 한다.
예를들어, A\[1\]이 원래 3이었는데, 1로 바꾼다고 한다면(업데이트 한다면)

update(1, -3);
update(1, 1);
처럼 수행해야 한다. 위를 한번에 수행하려면,

update(1, -3+1); 즉, update(1,-2)로 수행 할 수 있고,
이를 일반화 하여 표현하면,

update(idx, NewValue-A\[idx\]); 로 표현 하면 된다.

update 코드에서는  인덱스 + LSB(인덱스) 를 반복적으로 수행하며 진행된다.

```
void update(int idx, int val)
{
    while(idx <= maxidx)
    {
        bit[idx] += val;
        idx += (idx & -idx);
    }
}
```

bit를 이용해서 풀 수 있는 문제들은 다음과 같
\-배열의 부분합을 문제
: bit를 구현하고, sum(n)으로 구할 수있다.
: 중간중간 배열의 값을 바꾸는 update(idx, val)을 수행해야 하는 문제가 많

\-배열의 구간합을 구하는 문제 A\[start\] + .... A\[end\]
:위의 부분합과 유사한 문제인데,
구간합은 sum(end)-sum(start-1) 로 구할수 있음만 알면 된다.

\-k번째 수 찾기
: 배열을 정렬했을때 k번째로 작은 수를 찾는 문
즉, 정렬한 배열이 \[2,3,4,4,4,5,5,6,7,9\] 라
5번째 작은수는 4가 된다.
7번째 작은수는 5가 된다.

: 무식하게 찾는 방법은, 진짜로 배열을 정렬해서 k번째 값을 가져오는 건데,
정렬에 필요한 시간이 nlogn만큼 필요하므로 위의 쿼리가 m번 수행 된다면,
mnlogn만큼의 시간이 필요하게 된다. 너무 느리다.....

: bit를 이용해서 logn만에 찾을 수 있으므로, m번의 쿼리가 수행되어야 한다면,
mlogn으로 구할수 있다.
