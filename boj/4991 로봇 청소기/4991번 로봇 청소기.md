---
title: "4991번: 로봇 청소기"
source: "https://www.acmicpc.net/problem/4991"
author:
  - "[[스타트링크 (Startlink)]]"
published:
created: 2025-05-02
description:
tags:
  - "clippings"
---
| 시간 제한 | 메모리 제한 | 제출    | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ----- | ---- | ----- | ------- |
| 1 초   | 256 MB | 12868 | 4512 | 2989  | 32.419% |

오늘은 직사각형 모양의 방을 로봇 청소기를 이용해 청소하려고 한다. 이 로봇 청소기는 유저가 직접 경로를 설정할 수 있다.

방은 크기가 1×1인 정사각형 칸으로 나누어져 있으며, 로봇 청소기의 크기도 1×1이다. 칸은 깨끗한 칸과 더러운 칸으로 나누어져 있으며, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿀 수 있다.

일부 칸에는 가구가 놓여져 있고, 가구의 크기도 1×1이다. 로봇 청소기는 가구가 놓여진 칸으로 이동할 수 없다.

로봇은 한 번 움직일 때, 인접한 칸으로 이동할 수 있다. 또, 로봇은 같은 칸을 여러 번 방문할 수 있다.

방의 정보가 주어졌을 때, 더러운 칸을 모두 깨끗한 칸으로 만드는데 필요한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

입력은 여러 개의 테스트케이스로 이루어져 있다.

각 테스트 케이스의 첫째 줄에는 방의 가로 크기 w와 세로 크기 h가 주어진다. (1 ≤ w, h ≤ 20) 둘째 줄부터 h개의 줄에는 방의 정보가 주어진다. 방의 정보는 4가지 문자로만 이루어져 있으며, 각 문자의 의미는 다음과 같다.

- `.`: 깨끗한 칸
- `*`: 더러운 칸
- `x`: 가구
- `o`: 로봇 청소기의 시작 위치

더러운 칸의 개수는 10개를 넘지 않으며, 로봇 청소기의 개수는 항상 하나이다.

입력의 마지막 줄에는 0이 두 개 주어진다.

각각의 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 이동 횟수의 최솟값을 한 줄에 하나씩 출력한다. 만약, 방문할 수 없는 더러운 칸이 존재하는 경우에는 -1을 출력한다.

```
7 5
.......
.o...*.
.......
.*...*.
.......
15 13
.......x.......
...o...x....*..
.......x.......
.......x.......
.......x.......
...............
xxxxx.....xxxxx
...............
.......x.......
.......x.......
.......x.......
..*....x....*..
.......x.......
10 10
..........
..o.......
..........
..........
..........
.....xxxxx
.....x....
.....x.*..
.....x....
.....x....
0 0
```

```
8
49
-1
```

\> > > > > F번




#### 왜 비트마스크 등을 사용해서 "청소상태"를 점검하면서 경로를 찾아야 하는지 이해가 되지 않았는데, Cursor AI가 좋은 예를 들어 주었다.
#### 결론은, "꼭 청소 상태를 점검" 하면서 최단 경로를 찾아야 한다!!!!!!

아래의 cursor ai 의 설명들을 참조하면 좋고,
요약하면,
비트마스크 BFS : visited[y][x][state] 로 청소 상태까지 체크,
비트마스크는 *같은 위치도 다른 상태면 재방문 가능 하므로, 더 많은 경우의 수를 탐색하여 최적 경로를 보장한다!!!*


아래 부분을 |= 로 처리하지 않고 그냥 |
```cpp
nstate |= (1 << n);
```

```cpp
/*
- visited[y][x][청소상태비트마스크] 로 3차원 형태로 만들어서 청소상태에 따른 모든 경로를 탐색 해야 한다.
- pos 구조체를 만들어서, pos.y==ny && pos.x==nx 를 점검해서, "청소할곳" 인지를 확인 하자.
- Node 구조체를 만들어 사용하자, 이걸 큐에 넣자. int y, int x, int cost, int clean_state
*/

#include <stdio.h>

struct Node
{
    int y;
    int x;
    int cost;
    int state;    //비트마스크로 청소된 방을 모두표시
};

struct Pos
{
    int y;
    int x;
};

int dy[4] = {0,0,1,-1};
int dx[4] = {1,-1,0,0};

const int max = 20;
const int maxdirty = 10;
Node q[max*max*1024];   //더러운 칸의 최대 개수 10, 따라서 모든 경우의 수는 2^10 = 1024개(0~1023)
Pos dirty[maxdirty];      //더러운 방의 최대 개수 10
int v[max][max][1024];  //visited, 청소한칸의 정보를 포함해서 3차원으로 처리
int head, tail;

//입력
char map[max][max];
int w, h;

//필요한 변수 yoo
int dirtyCnt;   //더러운 칸의 개수

int bfs(Node s) //s:start
{
    //초기값 설정
    s.state = 0;    //아직 청소된 곳 없음
    s.cost = 0;     //아직 0

    //시작위치를 큐에 넣고 visited처리를 한다.
    q[tail++] = s;
    v[s.y][s.x][s.state] = 1;

    while(head < tail)
    {
        Node curr = q[head++];

        //더러운 칸이 모두 청소 되었으면 종료
        if(curr.state == (1 << dirtyCnt) - 1)   //ex. 더러운 칸이 3개라면, (1 << 3) -1 = (1000b)-1 = 111b
        {
            return curr.cost;
        }


        for (int i = 0; i < 4; i++)
        {
            int ny = curr.y + dy[i];
            int nx = curr.x + dx[i];
            int nstate = curr.state;

            //경계 조건 검사. ('.', '*', 그리고 'o'도 갈 수 있는곳이다!!!! 그냥 아래처럼 처리하면 제일 편하다)
            if(ny >= 0 && ny < h && nx >= 0 && nx < w && (map[ny][nx] != 'x'))
            {
                //다음 가볼 칸이 더러운 칸인지 확인해서, 청소를 완료한 상태(state)를 변경해 준다.
                for(int n=0; n<dirtyCnt; n++)
                {
                    if(dirty[n].y == ny && dirty[n].x == nx)
                    {
                        nstate |= (1 << n);  //여기를 그냥 or(|) 연산을 하면 안되고, 반드시 |= 해야 한다.
                        break;
                    }
                }

                //청소상태까지 고려하여, 다음 칸을 방문하지 않았을 경우에만 큐에 넣어 탐색한다.
                if(v[ny][nx][nstate] == 0)
                {
                    q[tail++] = Node{ny, nx, curr.cost+1, nstate};
                    v[ny][nx][nstate] = 1;
                }
            }
        }
        
    }

    // printf("더러운 칸이 남았어요\n");
    return -1;
}

void InitVisitedArr()
{
    for (int y = 0; y < max; y++)
    {
        for(int x=0; x< max; x++)
        {
            for(int state=0; state<(1<<maxdirty); state++)
            {
                v[y][x][state] = 0;
            }
        }
    }
    
}


int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
#endif

    Node start;

    //입력 처리
    while(1)
    {
        //초기화
        head = tail = 0;
        dirtyCnt = 0;
        InitVisitedArr();


        //w,h
        scanf("%d %d", &w, &h);

        // 00이 오면 테스트케이스 끝
        if (w == 0 && h == 0)
        {
            break;
        }

        //map[][]
        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                scanf(" %c", &map[y][x]);

                // 시작 위치
                if (map[y][x] == 'o')
                {
                    start.y = y;
                    start.x = x;
                }

                // 더러운 칸
                if (map[y][x] == '*')
                {
                    dirty[dirtyCnt].y = y;
                    dirty[dirtyCnt].x = x;
                    dirtyCnt++;
                }
            }
        }

        printf("%d\n", bfs(start));

    } // while end
}
```


```txt
1. 일반 BFS
큐: (1,1) -> 거리 0
큐: (1,2) -> 거리 1
큐: (2,2) -> 거리 2
큐: (2,3) -> 거리 3

2. 비트마스크 BFS
큐: (1,1,0b000) [청소X] -> 거리 0
큐: (1,2,0b001) [1번방 청소] -> 거리 1
큐: (1,2,0b010) [2번방 청소] -> 거리 1 (같은 위치, 다른 상태)
큐: (2,2,0b011) [1,2번방 청소] -> 거리 2
큐: (2,3,0b011) [1,2번방 청소] -> 거리 3

차이점:
- 일반 BFS: visited[y][x]로만 방문 체크
- 비트마스크 BFS: visited[y][x][state]로 청소 상태까지 체크
- 비트마스크는 같은 위치도 다른 상태면 재방문 가능
- 더 많은 경우의 수를 탐색하여 최적 경로 보장
```


```txt
/*
일반 BFS와 비트마스크 BFS의 차이점을 설명하는 예시입니다.

더 복잡한 맵 예시:
. . * . .
. o . o .
. . @ . .
. o . * .
. . . . .

@: 로봇의 시작 위치 (2,2)
o: 더러운 칸 (3개) - (1,1), (1,3), (3,1)
*: 벽
.: 빈 칸

일반 BFS의 경우:
1. (2,2)에서 시작해서 가장 가까운 더러운 칸 (1,1)로 이동: 2칸
2. (1,1)에서 다음으로 가까운 (1,3)으로 이동: 2칸
3. (1,3)에서 마지막 (3,1)로 이동: 4칸
총 이동 거리: 8칸

이동 경로:
(2,2) -> (1,2) -> (1,1) [첫 번째 더러운 칸]
(1,1) -> (1,2) -> (1,3) [두 번째 더러운 칸]
(1,3) -> (2,3) -> (2,2) -> (2,1) -> (3,1) [세 번째 더러운 칸]

비트마스크 BFS의 경우:
상태 = (현재위치, 청소상태)
더러운 칸의 상태: (1,1)=001, (1,3)=010, (3,1)=100

최적 경로:
(2,2) -> (2,1) -> (3,1) [상태: 100] : 2칸
(3,1) -> (2,1) -> (1,1) [상태: 101] : 2칸
(1,1) -> (1,2) -> (1,3) [상태: 111] : 2칸
총 이동 거리: 6칸

이 예시에서 일반 BFS는 단순히 현재 위치에서 
가장 가까운 더러운 칸을 선택하는 그리디 방식을 사용하여
전체 이동 거리가 8칸이 됩니다.

반면 비트마스크 BFS는 모든 가능한 방문 순서를 고려하여
전체적으로 가장 최적인 경로(6칸)를 찾아냅니다.

이처럼 단순 BFS로는 전체적인 최적해를 찾기 어렵고,
비트마스크를 이용한 상태 관리가 필요한 이유입니다.
*/
```


```
/*
중요한 점은 BFS가 "모든 가능한 경로"를 동시에 탐색한다는 것입니다.

예를 들어 (2,2)에서 시작할 때:
1. (2,1)로 이동하는 경우
2. (3,1)로 이동하는 경우 
3. (1,1)로 이동하는 경우

이 모든 경우를 큐에 넣고 병렬적으로 탐색합니다.
각 경우마다 다시 가능한 모든 이동을 큐에 넣습니다.

visited[y][x][state]를 통해:
- 같은 위치라도 다른 청소상태면 다른 경로로 인정
- 이미 방문한 위치+상태 조합은 제외 (더 긴 경로 제거)

따라서 (2,2)->(1,1) 같은 비효율적인 경로도 탐색하지만,
(2,2)->(2,1)->(3,1) 같은 효율적인 경로도 함께 탐색되어
결과적으로 최단 경로를 찾아낼 수 있습니다.

BFS의 특성상 최초로 모든 칸이 청소된 상태
(state == (1 << dirty_count) - 1)에 도달하는 경로가
곧 최단 경로가 됩니다.
*/
```


```
/*
비트마스크 BFS는 모든 가능한 방문 순서를 동시에 탐색합니다.
예를 들어 (2,2)에서 시작할 때:

1. (2,2)에서 (1,1)로 가는 경로도 탐색하고
2. (2,2)에서 (3,1)로 가는 경로도 동시에 탐색합니다

각 경로마다 청소 상태를 비트마스크로 기록하면서 진행하므로,
어떤 순서로 방문하는 것이 전체적으로 최단거리가 되는지
모든 경우의 수를 비교할 수 있습니다.

visited[y][x][state] 배열로 이미 방문한 상태는 건너뛰어
중복 탐색을 방지하면서도, 다른 방문 순서의 가능성은 남겨둡니다.

따라서 단순히 현재 위치에서 가장 가까운 곳만 선택하는 것이 아니라
모든 방문 순서를 고려하여 전체 거리가 최소가 되는 경로를 찾아냅니다.

예시의 경우:
1. (2,2)->(1,1) 경로 (8칸)
2. (2,2)->(3,1) 경로 (6칸)
두 가지를 모두 탐색하여 더 짧은 6칸 경로를 선택하게 됩니다.
*/
```


```txt
/*
일반 BFS와 비트마스크 BFS의 핵심적인 차이점을 설명하겠습니다:

1. 일반 BFS의 한계:
- 일반 BFS는 현재 위치에서 가장 가까운 더러운 칸을 선택합니다
- 이미 방문한 칸인지 아닌지만 체크합니다
- 따라서 (2,2)에서 시작하면 가장 가까운 (1,1)로 먼저 이동하게 됩니다
- 이는 전체 경로 관점에서는 최적이 아닐 수 있습니다

2. 비트마스크 BFS의 장점:
- 현재까지 청소한 상태를 비트마스크로 관리합니다
- 같은 위치라도 청소 상태가 다르면 다른 상태로 취급합니다
- 예: (2,1)에 도착했을 때
  - 상태 100(첫번째만 청소)인 경우와 
  - 상태 101(첫번째,세번째 청소)인 경우를 
  - 서로 다른 상태로 보고 모두 탐색합니다
- 이를 통해 모든 가능한 청소 순서를 탐색할 수 있습니다

3. 최적해를 찾는 과정:
- BFS 특성상 처음 도달하는 경로가 해당 상태까지의 최단경로입니다
- 모든 칸이 청소된 상태(111)에 처음 도달하는 경로가 전체 최적경로가 됩니다
- 중간에 거리가 좀 더 멀더라도, 전체적으로는 더 짧은 경로를 찾을 수 있습니다

따라서 비트마스크로 상태를 관리하면
단순히 현재 위치만이 아닌, 청소 진행 상황까지 고려한
진정한 의미의 최단 경로를 찾을 수 있습니다.
*/
```

```txt
/*
일반 BFS와 비트마스크 BFS의 차이를 더 자세히 설명하겠습니다:

1. 일반 BFS에서 청소 개수만 관리하는 경우의 문제점:
- 단순히 청소된 방의 개수만 관리하면
- "어떤 방들이" 청소되었는지는 알 수 없습니다
- 예: 2개의 방이 청소된 상태에서 (2,1)에 도착했을 때
  - (2,2)와 (1,1)이 청소된 경우와
  - (2,2)와 (1,3)이 청소된 경우는
  - 전혀 다른 상황이지만 구분할 수 없습니다

2. 비트마스크 BFS의 동작 방식:
- (2,2)에서 시작할 때 여러 경로를 "동시에" 탐색합니다
- (2,2) -> (2,1) -> (3,1) 경로도 큐에 넣고
- (2,2) -> (1,1) 경로도 큐에 넣습니다
- 각 경로마다 "정확히 어떤 방이 청소되었는지" 비트마스크로 기록합니다

3. 최단경로를 찾는 과정:
- BFS는 모든 가능한 경로를 너비 우선으로 탐색합니다
- 큐에서 꺼낸 현재 상태에서 이동 가능한 모든 방향을 시도합니다
- 각 상태(위치+청소상태)에 처음 도달하는 경로가 해당 상태까지의 최단경로입니다
- 결과적으로 모든 방을 청소하는 여러 경로 중 최단 경로를 찾아냅니다

따라서 단순히 청소된 방의 개수가 아닌,
정확히 어떤 방들이 청소되었는지를 관리해야
진정한 최단 경로를 찾을 수 있습니다.
*/
```

```txt
/*
죄송합니다. 거리 계산을 잘못했네요.
다시 정확하게 설명드리겠습니다:

미로 상태:
[S][1][ ]
[ ][2][ ]
[ ][ ][G]

S: 시작점
G: 도착점
1,2: 청소해야 하는 방

일반 BFS 큐 진행 상황:
큐: (S,청소상태:0) [아직 청소 안함] -> 거리 0
큐: (1번방,청소상태:1) [1번방만 청소] -> 거리 1
큐: (2번방,청소상태:3) [1,2번방 청소] -> 거리 2
큐: (G,청소상태:3) [모두 청소, 도착] -> 거리 3
총 거리: 3

실제 최적 경로의 큐 진행:
큐: (S,청소상태:0) [아직 청소 안함] -> 거리 0
큐: (2번방,청소상태:2) [2번방만 청소] -> 거리 1
큐: (1번방,청소상태:3) [1,2번방 청소] -> 거리 2
큐: (G,청소상태:3) [모두 청소, 도착] -> 거리 3
총 거리: 3

수정된 설명:
- 두 경로 모두 총 거리는 3으로 동일합니다
- 하지만 일반 BFS는:
  - 2번방에 도달했을 때 "1번방 청소 후" vs "직접 2번방으로" 
  - 이 두 상태를 구분하지 못해서
  - 가능한 모든 경로를 탐색하지 않을 수 있음
- 비트마스크 BFS는:
  - visited[y][x][청소상태]로 모든 상태를 구분
  - 같은 위치여도 청소 상태가 다르면 새로운 경로 탐색 가능

* 청소상태(비트마스크):
0 = 000 (아무것도 청소X)
1 = 001 (1번방 청소)
2 = 010 (2번방 청소)
3 = 011 (1,2번방 모두 청소)
*/
```