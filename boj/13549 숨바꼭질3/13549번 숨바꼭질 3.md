---
title: "13549번: 숨바꼭질 3"
source: "https://www.acmicpc.net/problem/13549"
author:
  - "[[스타트링크 (Startlink)]]"
published:
created: 2025-04-26
description:
tags:
  - "clippings"
  - 01 bfs
  - bfs
---
| 시간 제한 | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ------ | ----- | ----- | ------- |
| 2 초   | 512 MB | 136983 | 35929 | 23827 | 24.092% |

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2\*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

```
5 17
```

```
2
```

수빈이가 5-10-9-18-17 순으로 가면 2초만에 동생을 찾을 수 있다.




#### 현재보다 더 작은 비용으로 도착 할 수 있을 경우에만 큐에 넣는다.



```cpp
next = current+1 ; //current-1, current*2
if(next >= 0 && next < MAXSIZE && cost[next] > cost[current]+1)    
```




```cpp

#include <stdio.h>

const int MAXSIZE     = 100000 +1;

int cost[MAXSIZE] = {0};         // cost
int   q[MAXSIZE*2]    = {0};     //중복 삽입 될 수 있으므로 적절하게 3배 정도
int isQueued[MAXSIZE] = {0};
int head = 0;
int tail = 0;

int n;
int k;

int stepcnt = 0;

// int parent[MAX+1] = {-1};

// void printPath()
// {
//     for(int i=MAX; i>=0 ; i--)
//     {
//         if(parent[i] == -1)
//         {
//             continue;
//         }

//         printf("%d ", parent[i]);
//     }
//     printf("\n");
// }

void printQ()
{
    printf("after step %d queue : ", stepcnt);
    for(int i = head; i<tail; i++)
    {
        printf("%d ", q[i]);
    }
    printf("\n");
}

int bfs(int start, int end)
{
    q[tail++] = start;
    cost[start] = 0;
    // parent[start] = -1;

    while(head < tail)
    {
        stepcnt++;


        //get head
        int current = q[head++];
        int next;

        if(current == end)
        {
            return cost[current];
        }


        next = current+1;
        if(next >= 0 && next < MAXSIZE && cost[next] > cost[current]+1)    
        {
            cost[next] = cost[current] + 1; //next의 cost를 작은 값으로 갱신하고
            q[tail++] = next;               //next를 큐에 넣어 , 재 탐색을 하도록 한다.

            isQueued[next] += 1;
            if(isQueued[next] >= 2)
            {
                printf("1 stepcnt:%d, node:%d, enque cnt:%d, cost:%d\n",stepcnt, next, isQueued[next], cost[next]);
            }
        }

        //뒤로이동. 위의 앞으로 이동 설명 참고
        //current-1
        next = current-1;
        if(next >= 0 && next < MAXSIZE && cost[next] > cost[current]+1)
        {
            cost[next] = cost[current] + 1;
            q[tail++] = next;

            isQueued[next] += 1;
            if(isQueued[next] >= 2)
            {
                printf("2 stepcnt:%d, node:%d, enque cnt:%d, cost:%d\n",stepcnt, next, isQueued[next], cost[next]);
            }
        }

        //순간이동. 위의 앞으로 이동 설명 참고
        next = current*2;
        if(next >= 0 && next < MAXSIZE && cost[next] > cost[current]+0)
        {
            cost[next] = cost[current] + 0; 
            q[tail++] = next;

            isQueued[next] += 1;
            if(isQueued[next] >= 2)
            {
                printf("3 stepcnt:%d, node:%d, enque cnt:%d, cost:%d\n",stepcnt, next, isQueued[next], cost[next]);
            }
        }

        printQ();

    }

    printf("error\n");
    return -1;
}


int main()
{
    // printf("parent[0] : %d\n", parent[0]);

    scanf("%d %d", &n, &k);

    for(int i=0; i<MAXSIZE; i++)
    {
        cost[i] = 99999999;
        // parent[i] = -1;
    }
    printf("%d\n", bfs(n,k));

    // printPath();

    return 0;
}

```

 
- [1697번. 숨바꼭질](https://www.acmicpc.net/problem/1697)
- [12851번. 숨바꼭질 2](https://www.acmicpc.net/problem/12851)
- [13913번. 숨바꼭질 4](https://www.acmicpc.net/problem/13913)