---
tags: -histogram -algorithm -stack
created: 2024-06-20 00:50.12
updated: 2024-06-25 00:52.27
---


#### 시간복잡도 O(n2) O(n) 으로 모두 풀어보자


어떤 막대를 포함해서(좌우로 확장해서) 만들수 있는 가장 큰 직사각형은, 그 막대의 왼쪽, 오른쪽 진로를 가로막는 블로킹 막대의 위치를 알면 구할 수 있다.
편의상 블로킹 막대는 leftblock, rightblock 로 표기 하겠다.

maxarea = (rightblock - leftblock -1) * height


![[Screenshot_20240622_004059_Samsung Notes.jpg | 500]]

위 그림에서 인덱스 2번 막대(높이5)를 포함해서(좌우로 확장) 만들수 있는 직사각형을 생각해 보자.

왼쪽으로는 인덱스 1번 막대의 높이가(1) 2번 막대의 높이(5) 보다 낮기 때문에, 2번 막대는 더이상 왼쪽으로 진행하여 직사각형을 만들수 없다.

오른쪽으로는 인덱스 4번 막대의 높이가(2) 2번 막대의 높이(5) 보다 낮기 때문에, 2번 막대는 더이상 오른쪽으로 진행하여 사각형을 만들수 없다.

여기서 2번 막대의 진행을 가로막는 왼쪽 오른쪽 막대의 인덱스를 leftblock, rightblock라 부를것이고 , 이를 이용하여 직사각형의 넓이를 구해보면 다음과 같다.
(어느 설명에서는  prev, next 로 나타내기도 하더라. p n으로 쓰면 코딩할때 편하긴 할 것 같다)

```cpp
leftblock : 1, rightblock : 4, heigth : 5
width = rightblock - leftblock -1
      = 4-1-1 = 2
area = width x height = 2 x 5 = 10
```


### O(n) 스택 이용
```txt
어떤 막대가 더이상 오른쪽으로 진행 할 수 없을때, 이 막대를 오른쪽 끝으로 하여 만들수 있는 넓이를 한꺼번에 구해버리자!!!!
```

그럼 stack을 이용한 방법중 , 나를 고민하게 했던 내용에 대해 정리한다.

- 막대의 진행방향 한쪽이 블로킹되면 , 이 막대의 존재이유는 없어진다. 넓이 한번 구하고 사라져도 된다. 이해된다.
- 우리에게 중요한건 좌우 블로킹 막대의 인덱스이다. 중간에 막대가 없어져도 된다. 좌우 위치만 구할 수 있으면 된다. 이해된다.
- 스택을 이용해서 막대의 높이가 커지는 형태로만 막대의 인덱스를 저장하고, 높이가 낮은 막대가 나올때만 넓이를 구하자. 이해된다.
- 이러면 막대의 rightblock, leftblock를 구할때 발생하는 중복체크를 피할수 있다. 이해된다.
- 이때 나타나는 낮은 막대의 인덱스가 rightblock다. 이해된다.
- 첫번째 막대와 마지막 막대의 처리를 위해 가짜 데이터를 넣어주면 편하다. 
- 나는 오른쪽 끝에 높이 -1이라는 가짜 데이터를 넣는 방법을 사용했다.


지금 부터는 위 그림 기준으로 설명한다.
0~5번 막대의 높이, 2 1 5 6 2 3

(1) 0번 막대는 첫 막대이다. 비교할게 없으므로 스택에 넣는다.
(2) 1번 막대는 0번 막대보다 높이가 낮다! 0번 막대의 rightblock가 출현한 것이다. 0번 막대는 1번 막대에 막혀 더이상 오른쪽으로 진행 할 수 없다. 그러므로 이 시점에 0번 막대를 오른쪽 끝으로 하여 만들 수 있는 직사각형의 넓이를 구하면 된다.
(3) 우리는 0번 막대의 rightblock을 알아냈다. 1번 막대, 즉 1 이다.
rightblock = 1;
(4) 그럼 이제는 0번 막대의 leftblock를 구하자. 
0번 막대가 왼쪽으로 진행하는 걸 막는 막대의 인덱스는, 스택에서 0번 막대 바로 밑에 저장되어 있는 인덱스 일 것이다! 우리는 막대의 키순으로 저장되도록 스택을 설계 하였으니까 당연히 그럴것이다.

여기서 굉장히 오랜시간 고민한 문제가 있다. 
나는 0번 막대 자신만으로 만들어진 사각형의 넓이를 어떻게 구하지? 라는 고민을 했는데.
괜한 고민이었다.  다음의 세 가지 경우를 고려하면 되는데,

 -  pattern 1 : 만약 어떤 막대 바로 왼쪽에 그 막대보다 키작은 막대가 있었다면 leftblock는 현재막대 인덱스 보다 1 작은 값이 된다. 예를들어 0번 막대를 기준으로 하면 leftblock는 -1, 예를들어 16번 막대를 기준으로 하면 15번 등 등. 여튼 현재 막대를 pop하면 알 수 있다.

 - pattern 2 : 만약 어떤 막대 바로 왼쪽에 그 막대와 키가 같은 막대가 있었다면, leftblock는 더 pop을 해서 구해야 한다. 역시나 pop 하면 알 수 있다.
 - 
 - pattern 3 : pop을 계속했는데 statck이 비어있는 경우 - 왼쪽 끝까지 간 경우 이므로 가상의 인덱스인 -1이 leftblock이 된다. 다른 방법으로는 스택의 첫 데이터를 -1로 push해 놓고 시작해도 된다.
위에서 pop은 pop하려는 막대의 높이가 rightblock 보다 높을 경우에만 행해야 한다.
rightblock보다 높이가 낮은 막대는 rightblock를 가로 지를 수 있으므로 자기보다 낮은 높이의 막대가 나오는 시점에 넓이를 구해야 한다.

pop을 수행 하기 전에 , 현재 높이를 저장해 놓아야 한다.
height = mystack.top();

 자 그러면 0번 막대의 leftblock을 알기위해 0번 막대를 pop하자.
 mystack.pop();

이제 스택의 꼭대기에 있는 






![유튜브 좋은 강의](https://youtu.be/zx5Sw9130L0)



